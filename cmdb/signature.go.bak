package cmdb

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"sort"
	"strconv"
	"strings"
	"crypto/md5"
)

// 签名构建
type Signature struct {
	AccessKey   string    // access_key
	SecretKey   string    // srect_key
	RequestTime int64     // 时间戳
	Method      MethodStr // 请求方式 post 、 get
	Uri         string
	Data        interface{}
	ContentType string
}

// 获取签名（加密）
func RequestCmdb(uri string, ip string, method MethodStr, params interface{}) {
	// 请求地址
	reqUrl := ip + uri
	// 时间戳
	requestTime := int64(1642509454) //time.Now().Unix()
	fmt.Print("requestTime===>",requestTime)
	bytesData, err := json.Marshal(params)
	if paramsData, ok := params.(string); ok {
		fmt.Print("json字符串：：",paramsData)
		bytesData = []byte(paramsData)
	}
	if err != nil {
		fmt.Println(err.Error())
		return
	}
	// 创建签名
	signature := createSignature(Signature{
		AccessKey:   AccessKey,
		SecretKey:   ScrectKey,
		RequestTime: requestTime,
		Method:      method,
		Uri:         uri,
		Data:        params,
		ContentType: "application/json",
	})
	fmt.Println("签名signature ==> ", signature)
	keys := make(map[string]string)
	keys["accesskey"] = AccessKey
	keys["signature"] = signature
	keys["expires"] = strconv.FormatInt(requestTime, 10)
	var urlParams string
	if method == MethodStrGet || method == MethodStrDELETE {
		m := params.(map[string]string)
		urlParams = HttpBuildQuery(m) + "&" + HttpBuildQuery(keys)
	} else {
		urlParams = HttpBuildQuery(keys)
	}
	if find := strings.Contains(reqUrl, "?"); find {
		reqUrl = reqUrl + "&" + urlParams
	} else {
		reqUrl = reqUrl + "?" + urlParams
	}
	fmt.Println("\n reqUrl ==>",reqUrl,bytesData)
	fmt.Println("new_str1",bytes.NewBuffer(bytesData))
	fmt.Println("new_str2",bytes.NewReader(bytesData))
	fmt.Println("new_str3",string(bytesData))

	req, err := http.NewRequest("POST", reqUrl, bytes.NewReader(bytesData))
	req.Header.Set("Host", "openapi.easyops-only.com")
	//req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Content-Type", "application/json;charset=UTF-8")
	marshal, _ := json.Marshal(params)
	req.Header.Set("Content-MD5", Md5(marshal))

	// 发送请求
	// return
	client := &http.Client{}
	resp, err := client.Do(req)
	defer req.Body.Close()


	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		fmt.Println(" handle error===>", err)
	}
	fmt.Println("请求返回状态码：：",resp.StatusCode,"请求返回数据：：：",body, string(body))
}

// 生产signature信息
func createSignature(sign Signature) string {
	urlParams := ""
	bodyContent := ""
	if sign.Method == MethodStrGet || sign.Method == MethodStrDELETE {
		var keys []string

		fmt.Print(sign.Data)
		if data, ok := sign.Data.(map[string]string); ok {
			for k := range data {
				keys = append(keys, k)
			}
			sort.Strings(keys)
			var urlParamsArray []string
			for _, k := range keys {
				urlParamsArray = append(urlParamsArray, k+data[k])
			}
			urlParams = strings.Join(urlParamsArray, "")
			fmt.Println("\nurlParams =>>>>>",urlParams)
		}
	}
	if sign.Method == MethodStrPOST || sign.Method == MethodStrPUT {
		if data, ok := sign.Data.(string); ok {
			fmt.Print("sign.Data===>",data)
			bodyContent = Md5([]byte(data))
			//bodyContent = md5V2(data)
		} else {
			/*indent, _ := json.MarshalIndent(sign.Data, "", "")
			replace := strings.Replace(string(indent), "\n", "", -1)
			replace = strings.Replace(replace, ",\"", ", \"", -1)
			bodyContent = Md5([]byte(replace))
*/
			//fmt.Print("replace=>",replace)
			marshal, _ := json.Marshal(sign.Data)
			bodyContent = Md5String(string(marshal))
			

		}
	}
	signData := []string{
		string(sign.Method),
		sign.Uri,
		urlParams,
		sign.ContentType,
		bodyContent,
		strconv.FormatInt(sign.RequestTime, 10),
		sign.AccessKey,
	}
	strSign := strings.Join(signData, "\n")
	fmt.Println("\n strSign ==>",strSign)
	return HmacSha1([]byte(sign.SecretKey), strSign)
}


func md5V2(str string) string {
	data := []byte(str)
	has := md5.Sum(data)
	md5str := fmt.Sprintf("%x", has)
	return md5str
}

func HttpBuildQuery(params map[string]string) (paramStr string) {
	paramsArr := make([]string, 0, len(params))
	for k, v := range params {
		paramsArr = append(paramsArr, fmt.Sprintf("%s=%s", k, v))
	}
	paramStr = strings.Join(paramsArr, "&")
	return paramStr
}